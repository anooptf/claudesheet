<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QuickSheet</title>
<style>
:root {
  --border: #d0d0d0;
  --border-dark: #aaa;
  --header-bg: #f0f0f0;
  --header-text: #555;
  --text: #111;
  --sel-bg: #cce5ff;
  --sel-border: #1a73e8;
  --anchor-bg: #e8f4ff;
  --fp-bg: #fffacd;
  --fp-border: #d4a800;
  --fp-anchor: #b8d4ff;
  --fh1: #aee6ae; --fh1b: #1a8a1a;
  --fh2: #f9c0c0; --fh2b: #c00000;
  --fh3: #ffd580; --fh3b: #a06000;
  --fh4: #c8b4f0; --fh4b: #5020a0;
  --fh5: #80d8f0; --fh5b: #006080;
  --status-bg: #f7f7f7;
  --err: #cc0000;
  --mono: 'Courier New', monospace;
  --sans: 'Segoe UI', Arial, sans-serif;
}
* { box-sizing: border-box; margin: 0; padding: 0; }
body { background: #e0e0e0; font-family: var(--sans); font-size: 13px; height: 100vh; display: flex; flex-direction: column; overflow: hidden; color: var(--text); }
#topbar { display: flex; align-items: center; gap: 10px; padding: 4px 10px; background: #fff; border-bottom: 1px solid var(--border-dark); flex-shrink: 0; }
#logo { font-size: 14px; font-weight: 700; color: #1a73e8; letter-spacing: 1px; margin-right: 4px; }
#selref { font-size: 12px; color: #555; font-family: var(--mono); min-width: 72px; }
#hintbar { font-size: 11px; color: #888; flex: 1; }
#hintbar b { color: #333; }
#clearbtn { background: #fff; border: 1px solid #ccc; color: #c00; padding: 3px 10px; cursor: pointer; border-radius: 3px; font-size: 12px; white-space: nowrap; }
#clearbtn:hover { background: #fff0f0; }
#gridwrap { flex: 1; overflow: auto; }
table { border-collapse: collapse; table-layout: fixed; background: #fff; }
th, td { border: 1px solid var(--border); padding: 0; }
th.corner { width: 44px; min-width: 44px; background: var(--header-bg); position: sticky; top: 0; left: 0; z-index: 4; border-color: var(--border-dark); }
th.colh { width: 90px; min-width: 90px; background: var(--header-bg); color: var(--header-text); font-size: 11px; font-weight: 600; text-align: center; padding: 3px 0; position: sticky; top: 0; z-index: 3; user-select: none; border-color: var(--border-dark); }
th.colh.hi { background: #c8dcf8; color: #1a73e8; }
td.rowh { width: 44px; min-width: 44px; background: var(--header-bg); color: var(--header-text); font-size: 11px; text-align: right; padding: 0 5px 0 0; position: sticky; left: 0; z-index: 2; user-select: none; border-color: var(--border-dark); }
td.rowh.hi { background: #c8dcf8; color: #1a73e8; }
td.cell { width: 90px; min-width: 90px; height: 22px; background: #fff; cursor: cell; position: relative; }
td.cell.s  { background: var(--sel-bg); }
td.cell.a  { background: var(--anchor-bg); box-shadow: inset 0 0 0 2px var(--sel-border); z-index: 1; }
td.cell.fr { background: var(--fp-bg); box-shadow: inset 0 0 0 2px var(--fp-border); z-index: 2; }
td.cell.fa { background: var(--fp-anchor); box-shadow: inset 0 0 0 2px var(--sel-border); z-index: 2; }
td.cell.fh0 { background: var(--fh1); box-shadow: inset 0 0 0 2px var(--fh1b); z-index: 2; }
td.cell.fh1 { background: var(--fh2); box-shadow: inset 0 0 0 2px var(--fh2b); z-index: 2; }
td.cell.fh2 { background: var(--fh3); box-shadow: inset 0 0 0 2px var(--fh3b); z-index: 2; }
td.cell.fh3 { background: var(--fh4); box-shadow: inset 0 0 0 2px var(--fh4b); z-index: 2; }
td.cell.fh4 { background: var(--fh5); box-shadow: inset 0 0 0 2px var(--fh5b); z-index: 2; }
td.cell span.v { display: block; width: 100%; height: 100%; padding: 2px 4px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-family: var(--mono); font-size: 12px; text-align: right; line-height: 18px; user-select: none; pointer-events: none; }
td.cell span.v.t { text-align: left; }
td.cell span.v.e { color: var(--err); text-align: left; font-size: 11px; }
td.cell input { position: absolute; inset: 0; width: 100%; height: 100%; font-family: var(--mono); font-size: 12px; padding: 2px 4px; border: 2px solid var(--sel-border); background: #fff; color: var(--text); outline: none; z-index: 20; }
#statusbar { display: flex; align-items: center; background: var(--status-bg); border-top: 1px solid #ddd; flex-shrink: 0; height: 24px; font-size: 12px; }
.sstat { padding: 3px 12px; border-right: 1px solid #ddd; color: #333; white-space: nowrap; }
.sstat b { color: #1a73e8; }
#sempty { padding: 3px 12px; color: #aaa; font-size: 11px; }
</style>
</head>
<body>
<div id="topbar">
  <div id="logo">QSHEET</div>
  <div id="selref">A1</div>
  <div id="hintbar">
    <b>Click/Drag</b> select &nbsp;路&nbsp; <b>Enter/F2</b> edit &nbsp;路&nbsp; <b>Del</b> clear &nbsp;路&nbsp; <b>Ctrl+C/V</b> copy/paste &nbsp;路&nbsp;
    Formula: type <b>=SUM(</b> then use <b>arrows</b> to navigate, <b>Shift+arrows</b> or <b>Shift+click</b> to extend range, <b>Enter</b> confirms
  </div>
  <button id="clearbtn">CLEAR ALL</button>
</div>
<div id="gridwrap"><table id="tbl"></table></div>
<div id="statusbar"><div id="sempty">Select cells to see statistics</div></div>

<script>
const ROWS=100, COLS=26;
const cn=c=>String.fromCharCode(65+c);
const cid=(r,c)=>cn(c)+(r+1);

const D=Array.from({length:ROWS},()=>Array(COLS).fill(''));
const V=Array.from({length:ROWS},()=>Array(COLS).fill(''));

// undo/redo
const undoStack=[], redoStack=[];
const MAX_UNDO=200;
function snapshot(){
  // deep copy of D
  return Array.from({length:ROWS},(_,r)=>D[r].slice());
}
function pushUndo(){
  undoStack.push(snapshot());
  if(undoStack.length>MAX_UNDO) undoStack.shift();
  redoStack.length=0; // clear redo on new action
}
function applyState(state){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) D[r][c]=state[r][c];
  paintAll();
}
function undo(){
  if(!undoStack.length) return;
  redoStack.push(snapshot());
  applyState(undoStack.pop());
}
function redo(){
  if(!redoStack.length) return;
  undoStack.push(snapshot());
  applyState(redoStack.pop());
}

// normal selection
let ar=0,ac=0,sr=0,sc=0;
let mdown=false;

// edit state
let eR=-1,eC=-1,eEl=null;

// formula pick state
let fp=false;
let fpAr=0,fpAc=0; // anchor of range
let fpCr=0,fpCc=0; // cursor (extended end)
let fpIns=0;       // insert position in input string
let fpLen=0;       // length of currently injected token
let fpMdown=false;

const sR1=()=>Math.min(ar,sr), sC1=()=>Math.min(ac,sc);
const sR2=()=>Math.max(ar,sr), sC2=()=>Math.max(ac,sc);
const inS=(r,c)=>r>=sR1()&&r<=sR2()&&c>=sC1()&&c<=sC2();

// build DOM
const tbl=document.getElementById('tbl');
const tbod=document.createElement('tbody');
const hrow=document.createElement('tr');
hrow.appendChild(Object.assign(document.createElement('th'),{className:'corner'}));
for(let c=0;c<COLS;c++){
  const th=document.createElement('th');
  th.className='colh';th.id='ch'+c;th.textContent=cn(c);
  hrow.appendChild(th);
}
tbod.appendChild(hrow);

const CE=[];
for(let r=0;r<ROWS;r++){
  CE[r]=[];
  const tr=document.createElement('tr');
  const rh=document.createElement('td');
  rh.className='rowh';rh.id='rh'+r;rh.textContent=r+1;
  tr.appendChild(rh);
  for(let c=0;c<COLS;c++){
    const td=document.createElement('td');
    td.className='cell';td.dataset.r=r;td.dataset.c=c;
    const sp=document.createElement('span');sp.className='v';
    td.appendChild(sp);

    td.addEventListener('mousedown',ev=>{
      if(ev.target.tagName==='INPUT') return;
      if(fp){
        ev.preventDefault();
        if(ev.shiftKey){
          // extend range
          fpCr=r; fpCc=c;
        } else {
          // new anchor
          fpAr=r; fpAc=c; fpCr=r; fpCc=c;
        }
        fpMdown=true;
        fpInject(); fpPaint();
        if(eEl){ eEl.focus(); eEl.setSelectionRange(fpIns+fpLen,fpIns+fpLen); }
        return;
      }
      if(eEl) commitEdit();
      mdown=true;
      if(ev.shiftKey){sr=r;sc=c;}
      else{ar=r;ac=c;sr=r;sc=c;}
      paintSel(); ev.preventDefault();
    });
    td.addEventListener('mouseover',()=>{
      if(fp&&fpMdown){ fpCr=r;fpCc=c; fpInject();fpPaint(); return; }
      if(!mdown) return;
      sr=r;sc=c;paintSel();
    });
    td.addEventListener('mouseup',()=>{ fpMdown=false; });
    td.addEventListener('dblclick',()=>{ if(!eEl) startEdit(r,c); });
    tr.appendChild(td); CE[r][c]=td;
  }
  tbod.appendChild(tr);
}
tbl.appendChild(tbod);
document.addEventListener('mouseup',()=>{ mdown=false; fpMdown=false; });

// ---- formula engine ----
function pRef(s){
  const m=s.match(/^([A-Z]+)(\d+)$/i); if(!m) return null;
  const col=m[1].toUpperCase().split('').reduce((a,x)=>a*26+x.charCodeAt(0)-64,0)-1;
  const row=parseInt(m[2])-1;
  return(row<0||row>=ROWS||col<0||col>=COLS)?null:[row,col];
}
function numV(r,c){ const v=V[r][c]; const n=Number(v); return(v===''||v===null||isNaN(n))?null:n; }
function calcCell(r,c,vis){
  const k=r+','+c; if(vis.has(k)) return'#CIRC';
  const raw=D[r][c]; if(!raw) return'';
  if(!raw.startsWith('=')){ const n=Number(raw); return isNaN(n)?raw:n; }
  const v2=new Set(vis); v2.add(k);
  try{ return evalF(raw.slice(1),v2); }catch(e){ return'#ERR: '+(e.message||'err'); }
}
function evalF(expr,vis){
  const strs=[];
  let s=expr.trim().replace(/"([^"]*)"/g,(_,x)=>{ strs.push(x); return'__'+(strs.length-1)+'__'; });
  function getRef(name){
    const p=pRef(name); if(!p) throw new Error('bad ref');
    const k=p[0]+','+p[1]; if(vis.has(k)) throw new Error('circular');
    const v2=new Set(vis); v2.add(k);
    const res=calcCell(p[0],p[1],v2);
    if(typeof res==='string'&&res.startsWith('#')) throw new Error(res);
    return res===''?0:res;
  }
  function rng(a,b){
    const p1=pRef(a),p2=pRef(b); if(!p1||!p2) throw new Error('bad range');
    const ns=[];
    for(let rr=Math.min(p1[0],p2[0]);rr<=Math.max(p1[0],p2[0]);rr++)
      for(let cc=Math.min(p1[1],p2[1]);cc<=Math.max(p1[1],p2[1]);cc++){
        const v=numV(rr,cc); if(v!==null) ns.push(v);
      }
    return ns;
  }
  function sArgs(s){ const a=[]; let d=0,c=''; for(const x of s){ if(x==='(')d++;else if(x===')')d--; if(x===','&&d===0){a.push(c);c='';}else c+=x; } if(c)a.push(c); return a; }
  function aNums(s){
    const ns=[];
    for(const t of sArgs(s)){
      const x=t.trim();
      const rm=x.match(/^([A-Z]+\d+):([A-Z]+\d+)$/i);
      if(rm) ns.push(...rng(rm[1],rm[2]));
      else if(/^[A-Z]+\d+$/i.test(x)){ const v=getRef(x); if(typeof v==='number') ns.push(v); }
      else{ const v=ex(x); if(typeof v==='number') ns.push(v); }
    }
    return ns;
  }
  function fn(name,args){
    const n=name.toUpperCase();
    if(n==='IF'){ const p=sArgs(args); if(p.length<3) throw new Error('IF needs 3 args'); return ex(p[0])?ex(p[1]):ex(p[2]); }
    if(n==='PI') return Math.PI; if(n==='E') return Math.E;
    const ns=aNums(args);
    switch(n){
      case'SUM': return ns.reduce((a,b)=>a+b,0);
      case'AVG': case'AVERAGE': return ns.length?ns.reduce((a,b)=>a+b,0)/ns.length:0;
      case'MIN': return Math.min(...ns); case'MAX': return Math.max(...ns);
      case'COUNT': return ns.length; case'ABS': return Math.abs(ns[0]);
      case'SQRT': return Math.sqrt(ns[0]);
      case'ROUND': return Math.round(ns[0]*10**(ns[1]||0))/10**(ns[1]||0);
      case'CEIL': return Math.ceil(ns[0]); case'FLOOR': return Math.floor(ns[0]);
      case'MOD': return ns[0]%ns[1]; case'POWER': return Math.pow(ns[0],ns[1]);
      case'LOG': return ns.length>1?Math.log(ns[0])/Math.log(ns[1]):Math.log10(ns[0]);
      case'LN': return Math.log(ns[0]); case'SIN': return Math.sin(ns[0]);
      case'COS': return Math.cos(ns[0]); case'TAN': return Math.tan(ns[0]);
      case'STDEV':{ const m=ns.reduce((a,b)=>a+b,0)/ns.length; return Math.sqrt(ns.reduce((a,b)=>a+(b-m)**2,0)/ns.length); }
      case'PRODUCT': return ns.reduce((a,b)=>a*b,1);
      default: throw new Error('unknown: '+name);
    }
  }
  function ex(e){
    let s=e.trim();
    s=s.replace(/__(\d+)__/g,(_,i)=>JSON.stringify(strs[+i]));
    let prev;
    do{ prev=s; s=s.replace(/\b([A-Za-z_]+)\(([^()]*)\)/g,(full,nm,ag)=>{
      if(!/^[A-Za-z]+$/.test(nm)) return full;
      const res=fn(nm,ag); return typeof res==='string'?JSON.stringify(res):String(res);
    }); }while(s!==prev);
    s=s.replace(/\b([A-Z]+\d+)\b/gi,(_,nm)=>{ const v=getRef(nm); return typeof v==='string'?JSON.stringify(v):String(v); });
    s=s.replace(/\^/g,'**');
    try{ return Function('"use strict";return ('+s+')')(); }
    catch(err){ throw new Error('syntax'); }
  }
  return ex(s);
}

function recalc(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
    try{ V[r][c]=calcCell(r,c,new Set()); }catch(e){ V[r][c]='#ERR'; }
  }
}
function paintCell(r,c){
  const sp=CE[r][c].querySelector('span.v'); if(!sp) return;
  const v=V[r][c];
  if(v===''||v===null||v===undefined){sp.textContent='';sp.className='v';return;}
  const isE=typeof v==='string'&&v.startsWith('#');
  const isT=typeof v==='string'&&!isE;
  sp.className='v'+(isE?' e':isT?' t':'');
  sp.textContent=typeof v==='number'?(Number.isInteger(v)?String(v):parseFloat(v.toPrecision(10)).toString()):String(v);
}
function paintAll(){ recalc(); for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) paintCell(r,c); updateStat(); }

function paintSel(){
  const r1=sR1(),c1=sC1(),r2=sR2(),c2=sC2();
  for(let r=0;r<ROWS;r++){
    document.getElementById('rh'+r).classList.toggle('hi',r>=r1&&r<=r2);
    for(let c=0;c<COLS;c++){
      const td=CE[r][c];
      td.classList.remove('a','s','fr','fa');
      if(r===ar&&c===ac) td.classList.add('a');
      else if(inS(r,c)) td.classList.add('s');
    }
  }
  for(let c=0;c<COLS;c++) document.getElementById('ch'+c).classList.toggle('hi',c>=c1&&c<=c2);
  const refEl=document.getElementById('selref');
  refEl.textContent=(ar===sr&&ac===sc)?cid(ar,ac):cid(r1,c1)+':'+cid(r2,c2);
  updateStat();
  CE[ar][ac].scrollIntoView({block:'nearest',inline:'nearest'});
}

// fp helpers
function fpToken(){
  const r1=Math.min(fpAr,fpCr),c1=Math.min(fpAc,fpCc);
  const r2=Math.max(fpAr,fpCr),c2=Math.max(fpAc,fpCc);
  return(r1===r2&&c1===c2)?cid(r1,c1):cid(r1,c1)+':'+cid(r2,c2);
}
function fpInject(){
  if(!eEl||!fp) return;
  const tok=fpToken();
  const v=eEl.value;
  eEl.value=v.slice(0,fpIns)+tok+v.slice(fpIns+fpLen);
  fpLen=tok.length;
}
function fpPaint(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) CE[r][c].classList.remove('fr','fa');
  if(!fp) return;
  const r1=Math.min(fpAr,fpCr),c1=Math.min(fpAc,fpCc);
  const r2=Math.max(fpAr,fpCr),c2=Math.max(fpAc,fpCc);
  for(let r=r1;r<=r2;r++) for(let c=c1;c<=c2;c++) CE[r][c].classList.add('fr');
  CE[fpAr][fpAc].classList.remove('fr'); CE[fpAr][fpAc].classList.add('fa');
  CE[fpCr][fpCc].scrollIntoView({block:'nearest',inline:'nearest'});
}
function fpEnter(){
  if(!eEl||fp) return;
  fpIns=eEl.selectionStart; fpLen=0;
  // start at current anchor cell
  fpAr=ar; fpAc=ac; fpCr=ar; fpCc=ac;
  fp=true;
  fpInject(); fpPaint();
}
function fpExit(keep){
  if(!fp) return;
  fp=false; fpMdown=false;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) CE[r][c].classList.remove('fr','fa');
  if(!keep&&eEl){
    const v=eEl.value;
    eEl.value=v.slice(0,fpIns)+v.slice(fpIns+fpLen);
    fpLen=0;
  }
}

// highlight all refs in a formula when editing
function highlightFormulaRefs(formula){
  clearFormulaHighlights();
  if(!formula.startsWith('=')) return;
  const expr=formula.slice(1);
  // extract all ranges and single refs
  const tokens=[];
  const rangeRe=/([A-Z]+\d+):([A-Z]+\d+)/gi;
  const refRe=/([A-Z]+\d+)/gi;
  let m;
  // collect ranges first
  const usedSpans=new Set();
  while((m=rangeRe.exec(expr))!==null){
    tokens.push({type:'range',a:m[1],b:m[2],idx:m.index});
    usedSpans.add(m.index+'_'+(m.index+m[0].length));
  }
  // collect single refs not part of a range
  while((m=refRe.exec(expr))!==null){
    // check not part of already captured range
    let inRange=false;
    for(const t of tokens){
      if(t.type==='range'&&m.index>=t.idx&&m.index<t.idx+t.a.length+t.b.length+1){inRange=true;break;}
    }
    if(!inRange) tokens.push({type:'ref',a:m[1],idx:m.index});
  }
  tokens.sort((a,b)=>a.idx-b.idx);
  tokens.forEach((tok,i)=>{
    const cls='fh'+(i%5);
    if(tok.type==='range'){
      const p1=pRef(tok.a),p2=pRef(tok.b);
      if(!p1||!p2) return;
      const r1=Math.min(p1[0],p2[0]),r2=Math.max(p1[0],p2[0]);
      const c1=Math.min(p1[1],p2[1]),c2=Math.max(p1[1],p2[1]);
      for(let r=r1;r<=r2;r++) for(let c=c1;c<=c2;c++) CE[r][c].classList.add(cls);
    } else {
      const p=pRef(tok.a); if(!p) return;
      CE[p[0]][p[1]].classList.add(cls);
    }
  });
}
function clearFormulaHighlights(){
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++)
    CE[r][c].classList.remove('fh0','fh1','fh2','fh3','fh4');
}

function updateStat(){
  const r1=sR1(),c1=sC1(),r2=sR2(),c2=sC2();
  const ns=[];
  for(let r=r1;r<=r2;r++) for(let c=c1;c<=c2;c++){ const v=numV(r,c); if(v!==null) ns.push(v); }
  const sb=document.getElementById('statusbar');
  if(!ns.length){sb.innerHTML='<div id="sempty">Select cells with numbers to see statistics</div>';return;}
  const sum=ns.reduce((a,b)=>a+b,0),avg=sum/ns.length;
  const fmt=v=>Number.isInteger(v)?String(v):parseFloat(v.toPrecision(8)).toString();
  sb.innerHTML=`<div class="sstat"><b>SUM</b> ${fmt(sum)}</div><div class="sstat"><b>AVG</b> ${fmt(avg)}</div><div class="sstat"><b>COUNT</b> ${ns.length}</div><div class="sstat"><b>MIN</b> ${fmt(Math.min(...ns))}</div><div class="sstat"><b>MAX</b> ${fmt(Math.max(...ns))}</div>`;
}

function startEdit(r,c,initVal){
  if(eEl) commitEdit();
  ar=r;ac=c;sr=r;sc=c; paintSel();
  eR=r;eC=c;
  const inp=document.createElement('input');
  inp.value=initVal!==undefined?initVal:(D[r][c]||'');
  CE[r][c].appendChild(inp); eEl=inp; inp.focus();
  if(initVal!==undefined) inp.setSelectionRange(inp.value.length,inp.value.length);
  else inp.select();
  // highlight formula refs on F2 open
  if(initVal===undefined&&D[r][c].startsWith('=')) highlightFormulaRefs(D[r][c]);

  inp.addEventListener('keydown',ev=>{
    const isF=inp.value.startsWith('=');
    const arrows=['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'];

    if(ev.key==='Enter'){
      ev.preventDefault();
      if(fp){ fpExit(true); return; } // Enter while in fp: confirm range, stay editing
      commitEdit();
    }
    else if(ev.key==='Tab'){
      ev.preventDefault();
      if(fp) fpExit(true);
      commitEdit(); move(0,ev.shiftKey?-1:1);
    }
    else if(ev.key==='Escape'){
      ev.preventDefault();
      if(fp){ fpExit(false); return; }
      cancelEdit();
    }
    else if(arrows.includes(ev.key)&&isF){
      ev.preventDefault();
      if(!fp) fpEnter();
      const dr=ev.key==='ArrowUp'?-1:ev.key==='ArrowDown'?1:0;
      const dc=ev.key==='ArrowLeft'?-1:ev.key==='ArrowRight'?1:0;
      if(ev.ctrlKey||ev.metaKey){
        // Ctrl+Arrow: jump to data edge
        const[tr,tc]=ctrlJump(fpCr,fpCc,dr,dc);
        if(ev.shiftKey){ fpCr=tr; fpCc=tc; }
        else { fpAr=tr; fpAc=tc; fpCr=tr; fpCc=tc; }
      } else if(ev.shiftKey){
        // extend range
        fpCr=Math.max(0,Math.min(ROWS-1,fpCr+dr));
        fpCc=Math.max(0,Math.min(COLS-1,fpCc+dc));
      } else {
        // move single cell
        fpAr=Math.max(0,Math.min(ROWS-1,fpCr+dr));
        fpAc=Math.max(0,Math.min(COLS-1,fpCc+dc));
        fpCr=fpAr; fpCc=fpAc;
      }
      fpInject(); fpPaint();
    }
    else if(fp&&ev.key.length===1&&!ev.ctrlKey&&!ev.metaKey){
      // any printable key typed after fp: lock in the range and let the char be typed
      fpExit(true);
    }
  });

  inp.addEventListener('blur',()=>{
    setTimeout(()=>{ if(eEl&&!fp&&!fpMdown) commitEdit(); },200);
  });
}

function commitEdit(){
  if(!eEl) return;
  if(fp) fpExit(true);
  clearFormulaHighlights();
  const val=eEl.value;
  if(eEl.parentNode) eEl.parentNode.removeChild(eEl);
  eEl=null;
  if(val!==D[eR][eC]){ pushUndo(); D[eR][eC]=val; }
  eR=-1; eC=-1;
  paintAll();
}
function cancelEdit(){
  if(!eEl) return;
  if(fp) fpExit(false);
  clearFormulaHighlights();
  if(eEl.parentNode) eEl.parentNode.removeChild(eEl);
  eEl=null; eR=-1; eC=-1;
}
function move(dr,dc){
  ar=Math.max(0,Math.min(ROWS-1,ar+dr)); ac=Math.max(0,Math.min(COLS-1,ac+dc));
  sr=ar; sc=ac; paintSel();
}
function clrSel(){
  pushUndo();
  const r1=sR1(),c1=sC1(),r2=sR2(),c2=sC2();
  for(let r=r1;r<=r2;r++) for(let c=c1;c<=c2;c++) D[r][c]='';
  paintAll();
}

function ctrlJump(fromR,fromC,dr,dc){
  let r=fromR,c=fromC;
  const curFilled=D[r][c]!=='';
  if(curFilled){
    while(true){const nr=r+dr,nc=c+dc;if(nr<0||nr>=ROWS||nc<0||nc>=COLS)break;if(D[nr][nc]==='')break;r=nr;c=nc;}
  } else {
    while(true){const nr=r+dr,nc=c+dc;if(nr<0||nr>=ROWS||nc<0||nc>=COLS)break;r=nr;c=nc;if(D[r][c]!=='')break;}
  }
  return[r,c];
}
function lastUsed(){
  let mr=0,mc=0;
  for(let r=0;r<ROWS;r++)for(let c=0;c<COLS;c++)if(D[r][c]!==''){if(r>mr)mr=r;if(c>mc)mc=c;}
  return[mr,mc];
}

document.addEventListener('keydown',ev=>{
  if(eEl) return;
  const isArrow=['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(ev.key);
  if(isArrow){
    ev.preventDefault();
    const dr=ev.key==='ArrowUp'?-1:ev.key==='ArrowDown'?1:0;
    const dc=ev.key==='ArrowLeft'?-1:ev.key==='ArrowRight'?1:0;
    if(ev.ctrlKey||ev.metaKey){
      const[tr,tc]=ctrlJump(ar,ac,dr,dc);
      if(ev.shiftKey){sr=tr;sc=tc;paintSel();}
      else{ar=tr;ac=tc;sr=tr;sc=tc;paintSel();}
    } else if(ev.shiftKey){
      sr=Math.max(0,Math.min(ROWS-1,sr+dr));
      sc=Math.max(0,Math.min(COLS-1,sc+dc));
      paintSel();
    } else {
      move(dr,dc);
    }
  }
  else if(ev.key==='Home'){
    ev.preventDefault();
    if(ev.ctrlKey||ev.metaKey){if(ev.shiftKey){sr=0;sc=0;paintSel();}else{ar=0;ac=0;sr=0;sc=0;paintSel();}}
    else{if(ev.shiftKey){sc=0;paintSel();}else{ac=0;sc=0;paintSel();}}
  }
  else if(ev.key==='End'){
    ev.preventDefault();
    if(ev.ctrlKey||ev.metaKey){const[mr,mc]=lastUsed();if(ev.shiftKey){sr=mr;sc=mc;paintSel();}else{ar=mr;ac=mc;sr=mr;sc=mc;paintSel();}}
    else{const mc=COLS-1;if(ev.shiftKey){sc=mc;paintSel();}else{ac=mc;sc=mc;paintSel();}}
  }
  else if(ev.key==='Tab'){ev.preventDefault();move(0,ev.shiftKey?-1:1);}
  else if(ev.key==='Enter'){ev.preventDefault();move(1,0);}
  else if(ev.key==='F2'){ev.preventDefault();startEdit(ar,ac);}
  else if(ev.key==='Delete'||ev.key==='Backspace'){ev.preventDefault();clrSel();}
  else if(ev.key==='Escape'){ar=sr=0;ac=sc=0;paintSel();}
  else if((ev.ctrlKey||ev.metaKey)&&ev.key==='z'){ev.preventDefault();undo();}
  else if((ev.ctrlKey||ev.metaKey)&&ev.key==='y'){ev.preventDefault();redo();}
  else if((ev.ctrlKey||ev.metaKey)&&ev.key==='c'){ev.preventDefault();cpySel();}
  else if((ev.ctrlKey||ev.metaKey)&&ev.key==='v'){ev.preventDefault();pst();}
  else if(ev.key==='a'&&(ev.ctrlKey||ev.metaKey)){ev.preventDefault();ar=0;ac=0;sr=ROWS-1;sc=COLS-1;paintSel();}
  else if(ev.key.length===1&&!ev.ctrlKey&&!ev.metaKey){ev.preventDefault();startEdit(ar,ac,ev.key);}
});

function cpySel(){
  const r1=sR1(),c1=sC1(),r2=sR2(),c2=sC2();
  const rows=[];
  for(let r=r1;r<=r2;r++){const cols=[];for(let c=c1;c<=c2;c++){const v=V[r][c];cols.push(v===''||v===null?'':String(v));}rows.push(cols.join('\t'));}
  navigator.clipboard.writeText(rows.join('\n')).catch(()=>{});
}
function pst(){
  navigator.clipboard.readText().then(txt=>{
    pushUndo();
    const rows=txt.split('\n');
    for(let dr=0;dr<rows.length;dr++){
      const cols=rows[dr].split('\t');
      for(let dc=0;dc<cols.length;dc++){
        const r=ar+dr,c=ac+dc;
        if(r<ROWS&&c<COLS) D[r][c]=cols[dc].trim();
      }
    }
    paintAll();
  }).catch(()=>{});
}
document.getElementById('clearbtn').addEventListener('click',()=>{
  if(!confirm('Clear all data?')) return;
  pushUndo();
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) D[r][c]='';
  paintAll(); ar=sr=0;ac=sc=0; paintSel();
});

paintSel(); paintAll();
</script>
</body>
</html>
